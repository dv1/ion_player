=======================================================================================
OPEN:

* Add "all" playlist to GUI ("all" playlist = filter_playlist with no match function set)
* Add filter playlists to GUI; matching function shall use wildcards
* Make use of the systray for basic player control and minimizing to tray
* Import/export M3U
* Import/export individual playlists in JSON format
* Ability to edit metadata
* Configuration UIs for backend modules (decoders, sinks)
* UIs for editing settings for individual resources (the settings are stored as URI options)
* Playlist sorting
* Moving/cutting/copying/pasting playlist entries
* Provide UI for cancelling a directory scan
* Resource rescan action in UI
  store the URI to be re-scanned in a list, and when the scanner finishes, use this list entry to replace the old playlist entry metadata with the new one
  also mind errors like invalid_uri, resource_not_found etc. in this list's handling
* Add global loop support to frontend
* Add resource specific loop support to frontend
* UI for manual decoder specification for resources (implies a rescan)
* Handle I/O failures (for example, SMB share + network cable disconnected)
* Clicks on the scan indicator icon should open the scanner dialog in case of left clicks; right clicks shall show a context menu containing a "Cancel" and a "Show scanner dialog" item
* Save/restore playback status when changing backend
* change crash behavior to mark the existing one as broken + immediately move to the next resource (instead of retrying to play the existing one N times)
* Mark crashed/corrupt entries in playlist
* File/directory names are corrupt sometimes when adding them (they have a file:// prefix already sometimes)
* What to do if a file doesn't play because of an error (for instance, file not found)? Mark resource + transition/resource_finished.
  (Note: this does NOT refer to backend crashes)
* make it possible to insert new items in middle of playlist
* Implement playback history as described in design doc
* accelerate metadata scan by spawning the backend only at the beginning & when it crashes
* introduce a PING to scan and playback backends to detect hung up backends
* dragonsfunk.mod cannot be read by DUMB -> check that other decoders do not wrongly recognize it (mpg123 is particularly tolerant, and "recognizes" a lot of file types which it cannot play)
* audio/mods/MOD/Realms.mod causes DUMB to hang; before trying to fix it in the DUMB code, use this to test hang detection (that is, implement pings in frontend)
* allow for disabling the speex resampler at run-time, causing the backend to reinitialize the sink instead
  (pro: less CPU usage, potentially better sound quality  con: gapless playback only guaranteed if playback frequency does not change)
* Add shuffle
* Investigate shared memory for passing audio data to a visualizer (use boost.interprocess for this)
* Store in/restore from config the currently visible playlist
* Store in/restore from config the overall UI states (like column widths in the playlists)
* Removing a playlist while the metadata scanner is adding entries to it causes a crash; solution: let the scanner listen for playlist removed signal emissions
* uade decoder (only for file:// URIs!)
* StSound decoder (for YM music) (http://leonard.oxg.free.fr/)
* timidity decoder (for MIDIs) (http://timidity.sourceforge.net/)
* faad decoder
* sidplay decoder (http://sidplay2.sourceforge.net/)
* wavpack decoder (http://www.wavpack.com/)
* musepack (mpcdec) decoder (http://musepack.net/)
* modplug decoder (http://gnu.ethz.ch/linuks.mine.nu/modplugplay/)
* trueaudio (tta) decoder (http://en.true-audio.com/)
* in_cube or vgmstream decoder for Gamecube audio
* support mid-play metadata changes (including title, artist, album, song length, ....)
* volume control to adplug, gme, ogg vorbis decoders (-> write generic volume control function) - combine this with the resampler if possible, to minimize the amount of intermediate steps
* sampleformat conversion code (16->24 bit, 24->16, 16->32 bit float etc.) - combine this with the resampler if possible, to minimize the amount of intermediate steps
* mono->stereo conversion if source is mono - combine this with the resampler if possible, to minimize the amount of intermediate steps
* handle different sample formats and channel counts in decoders
* implement decoder deletion thread
* Windows waveout sink
* Pulseaudio sink
* JACK sink
* HTTP source
* RTSP source
* MMS source
* SHOUTcast source
[* post processing, VST support, UPnP]
* Examine code for undefined cases
* extensive testing (esp. fault tolerance)


=======================================================================================
DONE:

* Do not hide the scan indicator icon; disable it instead
* Give the scan indicator icon a tooltip showing the current status
* Log dialog close button should be handled better
* Change all boost lambda binds to boost phoenix binds
* Make settings dialog non-modal (necessary for the WebKit inspector dialog to work)
* add unrecognized_resource event & exception
* removing many items that succeed the currently playing one causes many unnecessary set_next_resource command calls
* fix FLAC assert.h problem in configure step (-> do not add the FLAC directory to include paths, only the FLAC++ one)
  possible solutions: (1) remove the FLAC include path from the config environment  (2) isolate the FLAC decoder further, to avoid FLAC <-> boost collisions
  [solved by letting go of the pkg-config package and manually finding flac++ headers/lib instead]
* change common_sink_base behavior: when the number of actually read samples < number requested samples, it shall NOT immediately move to the next decoder; only do that when 0 is returned
  (this is necessary for decoders like the vorbis one, since they may only give partial amounts sometimes, for example because the decoder's sample rate suddenly changes)
* game music emulator decoder
* ogg vorbis decoder
* adplug decoder
* flac decoder
* Add libbinio to extern/ folder & build it with waf
* Add code for scanning folders in background
* Removing items -> return their IDs to the unique_ids instance
* Restart playback backend if it crashes
* Display playback status in status bar
* Save/restore playlists
* Renaming and erasing of playlists
* Write custom sliders that allow for an instant jump to where the user clicked (instead of the "paged" jump style the default QSliders have)


=======================================================================================
BUG: resource_* signals cause crashes

This happens rarely. It is unknown why as of yet - signals2 uses shared_ptr, in which the crash originates. Observed using boost 1.40 - perhaps fixed in newer versions.


=======================================================================================
BUG: transitional deadlock in backend

1. set_next_decoder called, backend issues a decoder_mutex lock, common_sink_base issues a mutex lock
2. while step 1 is running, sink calls resource_finished
3. resource_finished tries to lock decoder_mutex, but since the sink loop locked the sink mutex, the code stops at this point

=> Conclusion: extremely short songs (< ~1s) cause race conditions in backend and common_sink_base

Reproduce with gamesmusic/tfmx/ contents and "race_conditions_commands" file. Disable the libmagic call in mpg123_decoder.cpp first, so mpg123 actually tries to
play the TFMX files.

SOLUTION: remove the mutex in common_sink_base; instead, supply the sink with a reference (!) to the backend's decoder_mutex. This implies that a lot of
unnecessary locks must be removed. Therefore, do this fix only when everything else is running ok, since it is quite invasive, and regressions WILL happen.

